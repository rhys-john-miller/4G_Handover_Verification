(*
    X2 Protocol in ProVerif


    Public Messages:
    msg1
    msg8
    msg14

    Ciphred Messages:
    msg2
    msg3
    msg4
    msg5
    msg6
    msg7
    msg9
    msg10
    msg11
    msg12
    msg13
*)

(*Channels for the Protocol Secret and Public*)
free pubch : channel. 

(*Constant Messages to alert failed or we are performing a packet switch request.*)
free PSR:bitstring.
free hndCMD:bitstring.
free hndCMDACK:bitstring.
free failMsg:bitstring.
free okHandover:bitstring.

(*--
    Variables in the Protocol
--*)

(*Key for encryption*)
type key. 
type sskey.
type spkey.

(*Security Algorithms*)
type alg. 

(*Capability Sets*)
type caps. 

(*Nonce Type*)
type nonce.

(*IMSI Type*)
type imsi.

(*--
    Functions
--*)

(*Tobitstring Converter Function*)
fun tobitstring (key) : bitstring[data,typeConverter].

(*Encryption for Nonces*)
fun noncetobitstring(nonce):bitstring[data,typeConverter].

(*-----------------------------------------------------------------*)
(*-----------------General Encryption Functions--------------------*)

(*Encryption and Decryption Functions*)
fun senc(alg, bitstring, key) : bitstring.
reduc forall a: alg, msg: bitstring, k: key; sdec(a, senc(a,msg,k),k) = msg.

(*Consset fuses alg and caps together to one set.*)
fun consset (alg , caps ): caps [ data ]. const emptyset : caps.

(*
    Predicate mem represents the set membership between the Security Algorithms
    and Capability Sets.
*)
pred mem(alg , caps).
clauses 
    (*The first clause states that mem(X,N) where n is the concatation of x and y*)
    forall x : alg, y: caps; mem( x , consset(x, y));
    (* The second clause states that mem(X,N) holds if N = consset(X′,N′)
     and mem(X,N′) holds, that is, if X is in the tail of N.*)
    forall x : alg, y: caps, z: alg; mem(x, y) -> mem(x, consset(z, y)).

(*KDF Function takes in a bitstring and key to produce another key. Used for Key generation*)
fun kdf(bitstring, key) : key.

(*MAC function takes in alg and a key. To produce an authentication code*)
fun mac (alg, key) : bitstring.

(*-----------------------------------------------------------------*)
(*-----------------Secret Channel Signature Functions--------------*)

(* Signature *)
fun spk(sskey):spkey.
fun sign(bitstring,sskey):bitstring.
reduc forall m:bitstring,k:sskey; getmsg(sign(m,k))=m.
reduc forall m:bitstring,k:sskey; verify(sign(m,k),spk(k))=m.

(* --- Events --- *)

(*Sanity check protocol can terminate.*) 
event terminateSend(bitstring).
event terminateAccept(key).

event kenbstarUE(key).
event kenbstarTE(key).

(*Log when the UE Starts*)
event UESendsMeasurementReport(bitstring,bitstring). (*after the report measurement; after msg1*)
event TNReceivesHORequestFromSE(bitstring). (*after the HO Request is received in TN from MME; after message 5;*)
event SNSendsHORequiredToTE(bitstring). (*after the HO Require is sent by SN to the TN; after message 3;*)
event SNReceivesHOCommandFromTE(alg). (*after the HO Command is received in SN from MME; after message 10;*)
event UEReceivesHOComand(alg).

(*Transfer Events*)
event endTransferTE(bitstring).
event middleTransferMME(bitstring).
event startTransfer(bitstring).

(*TNode is asked to do an HO for no reason, i.e., no UE has asked*)
query b:bitstring, b1:bitstring, b2:bitstring;
    event(TNReceivesHORequestFromSE(b)) ==> event(UESendsMeasurementReport(b1,b2)). (* TN asked to swap for no reason*)

(*SNode is finishing  a HO for no reason, i.e., no UE has asked*)
query a:alg, b1:bitstring, b2:bitstring;
    event(SNReceivesHOCommandFromTE(a)) ==>  event(UESendsMeasurementReport(b1,b2)).

(*SNode is finishing HO Commands in the due steps, with no input for UE*)
query a:alg, b1:bitstring, b2:bitstring, b3:bitstring;
    (event(SNReceivesHOCommandFromTE(a)) && event(SNSendsHORequiredToTE(b3)) )  ==> event(UESendsMeasurementReport(b1,b2)) .
 
(*TNode is transfering over, with no original ask for UE*) (*Need to
investigate why this does not prove*)
query b1:bitstring, ba:bitstring, bb:bitstring;
  event(startTransfer(b1)) ==> event(UESendsMeasurementReport(ba,bb)).

(*TNode is transfering over, with no original ask for UE*) (*Need to
investigate why this does not prove*)
query b1:bitstring, ba:bitstring, bb:bitstring;
  event(endTransferTE(b1)) ==> event(UESendsMeasurementReport(ba,bb)).

(*TNode is transfering over, with no original ask for UE*) (*Need to
investigate why this does not prove*)
query b1:bitstring, b2:bitstring;
    event(endTransferTE(b1)) ==> event(startTransfer(b2)).


(*!injective agreement now holds*)
query k:key;
    (inj-event(kenbstarUE(k)) ==> inj-event(kenbstarTE(k))).


(*--
    Processes
--*)

(*
    UE Process:

    Construction of a User Equipments Device:
    uecaps = algorithm supported by UE 
    kenb = key
    cellid = The id of target node used for key generation
*)
let UE(ueIMSI:imsi, uecaps : caps, kenb: key, cellid : bitstring, signK:sskey, pubkSN:spkey) =  

    (*msg 1*)
    (*Measurement Report.*)
    new radioSignal:bitstring;
    new PCI:bitstring;
    new ueNa:nonce;

    (*Log when the measurement report is sent.*)
    event UESendsMeasurementReport(radioSignal,PCI);

    let (patchSigmaMSR:bitstring) = sign((radioSignal, PCI, ueNa, ueIMSI), signK) in 

    out(pubch, patchSigmaMSR);



    in(pubch, sigmaPatchedHO:bitstring);

    let (asAlg:alg, ueNaFromSN:nonce) = verify(patchSigmaMSR, pubkSN) in 

    event UEReceivesHOComand(asAlg); 

    if ueNaFromSN = ueNa then

    (*Detach from the source enb*)

    (*Check to ensure the algorithm is in the UE accepted algorithm.*)
    if (mem(asAlg, uecaps)) then

        (*Key encryption method*)
        let kenbstar: key = kdf(cellid,kenb) in

        (*Log UE kenbstar*)
        event kenbstarUE(kenbstar);
    
        (*Mac Creation.*)
        let macVal: bitstring = mac(asAlg,kenbstar) in 

        (*Method to encrypt the data between the mac, key and algorithms*)
        let data: bitstring = senc(asAlg,macVal,kenbstar) in
        
        let (patchSigmaHC:bitstring) = sign((data, ueNa, ueIMSI), signK) in 
  
        out(pubch, patchSigmaHC);(*msg14*) 
0.

(*
    Source Node this is the node that are UE will start the process of at.
    This function Takes in the following properties:
    uecaps = algorithm supported by UE 
    kenb = key of ue
    cellid = The id of source node used for key generation
*)
let SeNodeB(uecaps: caps, kenb: key, cellid: bitstring, signk:sskey, pubkTE:spkey, pubkUE:spkey) =

    (*msg 1 Measurement Reports*)
    in(pubch, patchSigmaMSR:bitstring);

    let (radioSignal:bitstring, PCI:bitstring, ueNaFromUE:nonce, ueIMSI:imsi) = verify(patchSigmaMSR, pubkUE) in 

    event SNSendsHORequiredToTE(cellid);

    (*Takes the key and cellid to create an expected key.*)
    let kenbstar: key = kdf(cellid, kenb) in

    let sigma1:bitstring = sign((kenbstar,uecaps), signk) in 

    out(pubch, sigma1);

    in(pubch, sigma2:bitstring);

    let (asAlg:alg, =hndCMD) = verify(sigma2, pubkTE) in 

    let sigma3:bitstring = sign((kenbstar, hndCMDACK), signk) in 

    (*msg7 Establish X2 Transport Bearer*)
    out(pubch, sigma3);

    in(pubch, =okHandover);

    event SNReceivesHOCommandFromTE(asAlg);

    let sigmaPatchedHO:bitstring = sign((asAlg, ueNaFromUE), signk) in 

    (*UE Handover*)
    out(pubch, sigmaPatchedHO); (*msg 11*)

    new snTransfer:bitstring;

    event startTransfer(snTransfer);

    let sigma4:bitstring = sign((snTransfer), signk) in 
    
    out(pubch, sigma4);
0. 

(*
    Target Node B this is where we are trying to complete a handover to. 
    No properties are taken into this function.
*)
let TeNodeB(cellid: bitstring, kenb: key, signk:sskey, pubkSN:spkey, pubkMME:spkey, pubkUE:spkey) =

    in(pubch, sigma1:bitstring);

    let (kenbstar:key, uecaps:caps)  = verify(sigma1, pubkSN) in 

    event TNReceivesHORequestFromSE(cellid);
 
    (*This is sent by the seNode*)
    event kenbstarTE(kenbstar);
    
    (*If they can find an algorithm that matchs the capability set output on the secret channel.*)
    let rrcalg: alg suchthat mem(rrcalg, uecaps) in 

    let sigma2:bitstring = sign((rrcalg, hndCMD), signk) in 

    out(pubch, sigma2); (*msg6*)

    in(pubch, sigma3:bitstring);

    let (sourceKenbStar:key, =hndCMDACK)  = verify(sigma3, pubkSN) in 

    if sourceKenbStar = kenbstar then
        out(pubch, okHandover);
    
    if not(sourceKenbStar = kenbstar) then 
        out(pubch, failMsg);

    
    in(pubch,sigma4:bitstring);

    let (snTransfer:bitstring)  = verify(sigma4, pubkSN) in 

    event startTransfer(snTransfer);

    (*Handover Confirm*)
    in(pubch, patchSigmaHC: bitstring);

    let (data:bitstring, ueNaFromUE:nonce, ueIMSI:imsi) = verify(patchSigmaHC, pubkUE) in 

    (*if ueNaFromUE = ueNaFromSE then*)
    
    (*Decrypts the data to construct rrcmac*)
    let rrcmac:bitstring = sdec(rrcalg, data, kenbstar) in
    
    (*Check if the mac from the expect key is the right mac*)
    if rrcmac = mac(rrcalg, kenbstar) then
        (*Event to log termination of the protocol.*)
        event terminateSend(PSR);
        let sigma5:bitstring = sign((PSR), signk) in 
        out(pubch, sigma5); (*msg 17*)

    (*Handover Complete*)
    in(pubch, sigma6:bitstring); (*msg26*)
    let (nh_2:key, =PSR)  = verify(sigma6, pubkMME) in 

0.

(*
    Construction of the Mobile Management Entity.
    This function Takes in the following properties:
    nh_2 = Is derived from the KASME is to be used as a basis for the K∗eNB calculation in the next handover event 
*)
let MME(nh_2: key, kenb : key, signk:sskey, pubkTE:spkey) =

    (*Looks at the secret channel for the Packet Switch Request*)
    in(pubch, sigma5:bitstring);
    
    let (=PSR) = verify(sigma5, pubkTE) in 

    (*Log event of termination ending.*)
    event terminateAccept(nh_2);

    let sigma6:bitstring = sign((nh_2, PSR), signk) in 

    (*Broadcasts on the secret channel Ackknowledgement and the next hop 2 for next handover*)
    out(pubch, sigma6);(*msg26*)
0.

(* --- Global Process --- *)
process
    (*UE's accepted Algs.*)
    new a1: alg; 
    new a2: alg;

    (*Setting up of the UE's IMSI*)
    new ueIMSI: imsi;

    (*
        Key that would have been generated by the AKA protocol when it first 
        communicates with base station.
    *)
    new keyAKA: key;

    (*Secret Key for Signatures.*)
    new skUE:sskey;
    new skSE:sskey;
    new skTE:sskey;
    new skMME:sskey;

    (*Public Keys for Signatures.*)
    let pkUE=spk(skUE) in
    let pkSE=spk(skSE) in 
    let pkTE=spk(skTE) in 
    let pkMME=spk(skMME) in 

    (*Cell id of the base station we are trying to handover too.*)
    new cellidSource: bitstring;
    new cellidTarget: bitstring; 

    (*Creates a set of Algorithms that are being supported by the UE*)
    let uecaps = consset(a1, consset(a2,emptyset)) in

    (*Starts the Protocol by declaring these variables on the public channel.
    RRC Setup 
    *)
    out(pubch, (uecaps,cellidSource,cellidTarget));

    (*Setup of the keys for the protocol*)
    let kenb : key = kdf(cellidSource, keyAKA) in
    let nh_1 : key = kdf(tobitstring(kenb), keyAKA) in
    let nh_2 : key = kdf(tobitstring(nh_1), keyAKA) in
    
    (*Sets up the process running with their given values.*)
    (
        !(UE(ueIMSI ,uecaps, kenb, cellidSource, skUE, pkSE) ) |
        !(SeNodeB(uecaps, kenb, cellidSource, skSE, pkTE, pkUE)) |
        !(TeNodeB(cellidTarget, kenb, skTE, pkSE, pkMME, pkUE)) | 
        !(MME(nh_2, kenb, skMME, pkTE)) 
    )